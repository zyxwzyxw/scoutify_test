<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strategy Charts</title>
</head>
<style>
    body {
        overflow: hidden;
    }

    h1 {
        width: 100%;
        text-align: center;
    }

    div {
        display: inline-block
    }

    canvas {
        max-width: 40vw
    }

    ul {
        list-style: none;
    }

    details {
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: 0.5em 0.5em 0;
    }

    summary {
        font-weight: bold;
        margin: -0.5em -0.5em 0;
        padding: 0.5em;
    }

    details[open] {
        padding: 0.5em;
    }

    details[open] summary {
        border-bottom: 1px solid #aaa;
        margin-bottom: 0.5em;
    }

    #split-view-container {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100vw;
        height: 80vh;
      /*  overflow: hidden;*/
        overflow-x: hidden;
    }

    #split-view-divider {
        width: 2px;
        height: 100%;
        background-color: #aaa;
        margin-left: 2vw;
        margin-right: 2vw;
    }

    .split-view {
        width: 47%;
        height: 80%;
    }

    .scroller {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
        padding-bottom: none !important;
    }
    .scrollerOpen {
        padding-bottom: 200px !important;
    }
    
    td {
        border: 1px solid black;
    }
    th {
        border: 1px solid black;
        background: yellow;
        text-align: center;
    }
    table{text-align: right;}
    
    .ta-c {text-align: center}
</style>
<body>
    <h1>Charts</h1>

    <details open ontoggle="inputToggled()">
        <summary>UI: (click to open and close)</summary>
        <div id="ui"></div>
        <br>
        <button id="recalculate" onclick="calculate()">Calculate</button>
    </details>

    <div id="split-view-container">
        
        <div class="split-view">
            <h3>Strategy Comparison</h1>
                <details>
                    <summary>Key:</summary>
                    <ul>
                        <pre>
                        <li><mark style="background-color:rgb(0,255,0);">  </mark> : 3 RNKPNT</li>
                        <li><mark style="background-color:rgb(255, 255, 0);">  </mark> : 2 RNKPNT</li>
                        <li><mark style="background-color:rgb(255, 155, 0);">  </mark> : 1 RNKPNT</li>
                        <li><mark style="background-color:rgb(255,0,0);">  </mark> : 0 RNKPNT</li>
                    </pre>
                    </ul>
                </details>
                <div class="scroller">
                    <div style="display:block;">
                        <canvas id="psChart"></canvas>
                        <canvas id="piecesScoredchart"></canvas> <!--Total Score-Scenario Chart-->
                        <p>Note that the color indicator for this graph is inaccurate b/c the points overlap.
                            <canvas id="scenarioChart"></canvas> <!--Pieces vs Total Score-->
                        <p id="shiftkey"></p>
                        <canvas id="rnkpntChart"></canvas> <!--Ranking points vs Scenario id-->
                    </div>
                </div>
        </div>
        <div id="split-view-divider"></div>
        <div class="split-view">
            <h3 id="selectedScenario">Selected Scenario</h3>
            <div class="scroller scrollerOpen">
                <p id="tooltip"></p>
                <div style="display:block">
                    <details>
                        <summary>Key:</summary>
                        <ul>
                            <pre>
                            <li><mark style="background-color:rgb(0,0,0);">  </mark> : L4</li>
                            <li><mark style="background-color:rgb(150, 150, 150);">  </mark> : L3</li>
                            <li><mark style="background-color:rgb(200, 200, 200);">  </mark> : L2</li>
                            <li><mark style="background-color:rgb(255,255,255); border: 1px solid black">  </mark> : L1</li>
                        </pre>
                        </ul>
                    </details>
                    <canvas id="psotchart"></canvas>
                    <canvas id="myChart"></canvas>
                    <h3>Coral Scored by Level</h3>
                    <table>
                        <tr> <th>Scoring Level</th> <th># Scored</th> </tr>
                        <tr>
                            <td class="ta-c">L4</td>
                            <td id="L4_Scored"></td>
                        </tr>
                        <tr>
                            <td class="ta-c">L3</td>
                            <td id="L3_Scored"></td>
                        </tr>
                        <tr>
                            <td class="ta-c">L2</td>
                            <td id="L2_Scored"></td>
                        </tr>
                        <tr id="L1">
                            <td class="ta-c">L1</td>
                            <td id="L1_Scored"></td>
                        </tr>
                    </table>
                    <h3>Play by Play</h3>
                    <table id="table_id">
                        <tr>
                            <th>Event</th><th>Time Left</th><th>Elapsed Time</th>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
    <script>
        function l(..._){
            console.log(..._)
        }
        function inputToggled(){
            const scroller1=document.getElementsByClassName('scroller')[0]
            const scroller2=document.getElementsByClassName('scroller')[1]
            if(scroller1.classList.contains('scrollerOpen')){
                scroller1.classList.remove('scrollerOpen')
                scroller2.classList.remove('scrollerOpen')
            } else{
                scroller1.classList.add('scrollerOpen')
                scroller2.classList.add('scrollerOpen')
            }
        }

//reefscape

//new teleop/movement error - line 240 on calculate-fixed
//hide extra digits of end of scenario for hidden inputs like grabamount - done
//add table for different levels at end summary -fixed
//vertical instead of horizontal table -done
//color coded levels - fixed
//explain  "=teleop movement"-done
//explain scenatio in selected scenario- done

//check compatibility on presenting device before presenting to judges

//right align numbers, have number to 2 digits
//head table fix, add score to table

//algae



//assumptions:

//auton: mobility points and one high coral, if time permits remove algae and score 
//teleop: ignore lvl 3 and assume teamates can score 2 algae for co-op, our bot instead scoring levels 2,3,4 
//maybe add calculus with min and max to find optimum number? or is too complex

        const doLinksExist = false;
        const linkProgression = [2,2,2,2,2,2,2,2];//represents how many pieces makes a link, next number in a array is how many pieces constitutes the 2nd link, and so on and so forth: like in the game steamworks
        //for the steamship game, linkProgression=[1,2,3,4,5];
        //points arrays are structured as [points for auton, points for teleop]
        const linkPoints = [0, 0]
        const pointsForBalancing = [0, 12];
        const pointsForBestScorer = [7, 5];//lvl 4
        const pointsForMidScorer = [6, 4];//lvl 3
        const pointsForOkScorer = [4, 3];//lvl 2
        const pointsForWorstScorer = [3, 2];//lvl 1

        const pointsForTrap = [0, 0];
        const pointsForMobility = 3;
        const autonPieceLimit = 5;
        const holdPieceLimit = 1;
        //structure of piecesScoredForRnkPnt: [# of piecesScored[0] for RnkPnt,# of piecesScored[1] for RnkPnt]
        const piecesScoredForRnkPnt = [20, 0];
        
        //put iterating arrays in an array for ease of change
        const autonMovementName='Auton Movement (s) ["=Teleop" sets this to equal teleop movement]';
        let iteratingArrays = [//order the values from least to greatest
            //["path" , 0,1,2]//different paths mean different things
            ["Balance/Climb/Hang (s)",5,6],
            ["Output (s)",1.5,2,2.5],
            ["Intake (s)",.75,1,1.25],
            [autonMovementName,"=Teleop"],//all the movement times include aligning
            ["Teleop Movement (s)", 5, 6, 7],
            ["Alliance robots leave auton (Boolean)",0,1],
            ["At least one alliance robot parks (Boolean)",0,1],
            ["Algae dislodge (s)",1],
           // ["Stockpile Movement Fraction",1/2],
            ["Grab Amount (on average)", 1],

        ];
        
        //don't want to show grabAmount if it can only equal one, but it's still important, so it's hidden:
        const iteratingArraysVisibleInputOffset=1;

        //maxDecimals is helpful to pad numbers with extra zeros after decimal point
        const numbersToCheck=iteratingArrays.flat(1).filter(i => typeof i !== 'string');
        const maxDecimals = numbersToCheck.reduce((max, num) => {
            const decimalPart = num.toString().split('.')[1];
            return Math.max(max, decimalPart ? decimalPart.length : 0);
        }, 0);


        if(!sessionStorage.getItem('iteratingArrays')){
            sessionStorage.setItem('iteratingArrays', JSON.stringify(iteratingArrays))
        }
        else iteratingArrays = JSON.parse(sessionStorage.getItem('iteratingArrays'))

        const ui=document.getElementById("ui")
        for(let i =0; i<iteratingArrays.length;++i){
            if(i>=iteratingArrays.length-iteratingArraysVisibleInputOffset){
                ui.innerHTML +="<div style='display:none'>"+
                    iteratingArrays[i][0] + ": " +
                    `<input id="ui${i}" value="${iteratingArrays[i].slice(1)}" ><br>
                    </div>`
            }
            else ui.innerHTML +=
                iteratingArrays[i][0] + ": " +
                `<input id="ui${i}" value="${iteratingArrays[i].slice(1)}"><br>`
        }

        //reloads page with new data
        function calculate(){
            for(let i in iteratingArrays){
                let arr;

                if(iteratingArrays[i][0]==[autonMovementName]&&document.getElementById("ui"+i).value=="=Teleop"){
                    iteratingArrays[i]=[autonMovementName,"=Teleop"]
                }
                else{
                    arr=[iteratingArrays[i][0]]
                    arr.push(...document.getElementById("ui"+i).value.split(',').map(Number)) // Split the string by commas and convert each part to a number
                    iteratingArrays[i]=arr
                }
            }
            sessionStorage.setItem('iteratingArrays', JSON.stringify(iteratingArrays));
            location.reload();
        }

        //charts are structured as [{x:x1,y:y1},{x:x2,y:y2}...] 
        const allPointsVsTime = [], allPieceCountVsTime = [], rnkValueVsScenario = [], pieceCountVsScenario = [], totalScoreVsScenario = [], pieceCountVsTotalScore = [], specificPointsVsTime = [], specificPieceCountVsTime = [];
        const allColorOverTime=[], specificColorOverTime=[];
        //structured as ["rgb(1st scenario's color)","rgb(2nd scenario's color)"...]
        const color = [];
        const scenarioAction = [], scenarioTimes = [], pointsClicked = [], zeroIndicesPointsClicked = [];
        var scenario = { points: 0, time: 150, z: 0 };
        let piecesScored = [], holdingPiece = [], links = [];
        let numberOfScenarios = 1
        for (let i of iteratingArrays) { numberOfScenarios *= i.length - 1 }

        //turn a string that represents the indices in the scenario tree below into a number
        function encodeScenario(a) {
            let result = 0;
            let multiplier = 1;
            for (let i = a.length - 1; i >= 0; --i) {
                result += a.charAt(i) * multiplier
                multiplier *= iteratingArrays[i].length - 1
            }
            return result;
        }
        //undo the encodeScenario function by converting a scenario from the number format into the string format
        function decodeScenario(a) {
            let divisor = numberOfScenarios / (iteratingArrays[0].length - 1)
            let result = ""
            let remainder = a
            for (let i in iteratingArrays) {
                result += Math.floor(remainder / divisor);
                remainder -= Math.floor(remainder / divisor) * divisor;
                if (iteratingArrays[Number(i) + 1]) divisor /= iteratingArrays[Number(i) + 1].length - 1;
            }
            return result
        }

        function updatedata(scenario) {
            const visibleDecodeScenario=decodeScenario(scenario).substring(0,iteratingArrays.length-iteratingArraysVisibleInputOffset)
            
            // const scenarioStringified=iteratingArrays.slice(0,iteratingArrays.length-iteratingArraysVisibleInputOffset)
            //     .map( ([key, ...values]) => key + ": " + 
            //         //get time for action if defined. it being undefined is an unfixed autonmovement bug or algae dislodge error
            //         values[visibleDecodeScenario.at(key)]?? values[0]==="=Teleop" ? '=Teleop':10 ).join('<br>')
            
            const scenarioStringified = iteratingArrays.slice(0, iteratingArrays.length - iteratingArraysVisibleInputOffset)
                .map(([key, ...values]) => key + ": " +
                    (values[visibleDecodeScenario.at(key)] ?? (values[0] === "=Teleop" ? "=Teleop" : values[0]))
                ).join('<br>');
            document.getElementById("selectedScenario").innerHTML=
                "<details open>"+
                    "<summary> Selected Scenario: "+scenario+" - "+visibleDecodeScenario+"</summary>"+
                    "<p style='font-size: 16px; font-weight:normal'>"+ scenarioStringified+"</p>"
                "</details>";

                
            for (let i in scenarioTimes) {
                if (scenarioTimes[i].includes("-")) {
                    document.write("problem: a scenario takes longer than 2:30");
                    scenarioAction[i]-=0
                }
            }
            let scenarioDecoded = scenario;
            if (typeof (scenario) === "string") { scenarioDecoded = encodeScenario(scenario); }//this will allow the "arg: scenario" to be entered in string format or integer format
            const startpoint = endpoints[scenarioDecoded] + 1;//an accessor
            const endpoint = endpoints[scenarioDecoded + 1];
            const startpointofspecificPieceCountVsTime = endpointsofspecificPieceCountVsTime[scenarioDecoded] + 1;//an accessor
            const endpointofspecificPieceCountVsTime = endpointsofspecificPieceCountVsTime[scenarioDecoded + 1];
            //empty out the data arrays
            specificPointsVsTime.splice(0, specificPointsVsTime.length);
            specificPieceCountVsTime.splice(0, specificPieceCountVsTime.length);
            specificColorOverTime.splice(0, specificColorOverTime.length);

            //for each point in the given range, push a point to the specificPointsVsTime array
            for (let i = startpoint; i < endpoint + 1; i++) specificPointsVsTime.push(allPointsVsTime[i])

            for (let i = startpointofspecificPieceCountVsTime; i < endpointofspecificPieceCountVsTime + 1; i++) {
                specificPieceCountVsTime.push(allPieceCountVsTime[i]);
                specificColorOverTime.push(allColorOverTime[i]);
            }
            let string_copy = "";


            let table = document.getElementById("table_id");
            while(table.rows.length>1)
                table.deleteRow(1)

            for (let i in scenarioAction[scenarioDecoded]) {
                string_copy += scenarioAction[scenarioDecoded][i];
            }
            string_copy2 = "";
            for (let i in scenarioTimes[scenarioDecoded]) {
                string_copy2 += scenarioTimes[scenarioDecoded][i];
            }
            while (string_copy.length > 0) {
                let i = string_copy.indexOf(";");
                let j = string_copy2.indexOf(";");

                const tr = document.createElement("tr")
                const td0 = document.createElement("td");
                const td1 = document.createElement("td");
                const td2 = document.createElement("td");

                td0.innerText = string_copy.substring(0, i)
                td1.innerText = Number(string_copy2.substring(0, j)).toFixed(maxDecimals)
                td2.innerText = (150-string_copy2.substring(0, j)).toFixed(maxDecimals)
                
                
                string_copy = string_copy.substring(i + 1);
                string_copy2 = string_copy2.substring(j + 1);

                tr.appendChild(td0);
                tr.appendChild(td1);
                tr.appendChild(td2);
                document.getElementById("table_id").appendChild(tr);
            }

            let totalL4= specificColorOverTime.filter((a)=>a=='rgb(0,0,0)').length
            let totalL3= specificColorOverTime.filter((a)=>a=='rgb(150,150,150)').length
            let totalL2= specificColorOverTime.filter((a)=>a=='rgb(200,200,200)').length
            let totalL1= specificColorOverTime.filter((a)=>a=='rgb(255,255,255)').length
            document.getElementById('L1_Scored').innerHTML=totalL1
            document.getElementById('L2_Scored').innerHTML=totalL2
            document.getElementById('L3_Scored').innerHTML=totalL3
            document.getElementById('L4_Scored').innerHTML=totalL4
        }
        function autonScorePiece(scenarioEncoded) {
            piecesScored[0] += holdingPiece[0];
            scenario.time -= scenario["Output (s)"];
            scenario.points += pointsForBestScorer[0] * holdingPiece[0];
            holdingPiece[0] = 0;
            allColorOverTime.push('rgb(0,0,0)')
            
            addPlotData(scenarioEncoded, "score coral in Lvl4")
        }
        function scorePiece(scenarioEncoded, alreadyHoldingAndPositioned) {
            if(piecesScored[0]==5||piecesScored[0]==7||piecesScored[0]==9){//(piecesScored[0]-1<=10&&piecesScored[0]-1>5&& !(piecesScored[0]-1)%2 /*for every first of the two L3*/){
                scenario.time-=scenario['Algae dislodge (s)'];
            }
            piecesScored[0] += holdingPiece[0];
            holdingPiece[0] = 0;

            scenario.time -= scenario["Teleop Movement (s)"] + scenario["Output (s)"] + scenario["Intake (s)"];
            if (alreadyHoldingAndPositioned) {
                scenario.time += scenario["Teleop Movement (s)"] + scenario["Intake (s)"];
            }
            
            let linkscored = false
            if(doLinksExist){
                let sum=0

                for(let i of linkProgression){
                    sum+=i
                    if(piecesScored[0]-sum==0){
                        scenario.points+=linkPoints[1]
                        linkscored=true
                    }
                }
            }
            let pieceName='coral';
            let targetName;
            if(piecesScored[0]<=5){
                targetName = "Lvl4"
            }else if(piecesScored[0]<=10){
                targetName = "Lvl3"
            }else if (piecesScored[0]<=15) {
                targetName="Lvl2"
            }
            else if (piecesScored[0]<=20){
                targetName="Lvl1"
            }
            else if (piecesScored[0]<=27){
                targetName="Lvl4"
            }
            else{
                targetName='Lvl1'
            }
    
            
            if(targetName=="Lvl1"){
                scenario.points+=pointsForWorstScorer[1]
                allColorOverTime.push('rgb(255,255,255)')
            }
            else if(targetName=="Lvl2"){
                scenario.points+=pointsForOkScorer[1]
                allColorOverTime.push('rgb(200,200,200)')
            }
            else if(targetName=="Lvl3"){
                scenario.points+=pointsForMidScorer[1]
                allColorOverTime.push('rgb(150,150,150)')
            }
            else if(targetName=="Lvl4"){
                scenario.points+=pointsForBestScorer[1]
                allColorOverTime.push('rgb(0,0,0)')
            }


            if(linkscored) addPlotData(scenarioEncoded, "scored piece & link")
            else addPlotData(scenarioEncoded, "scored "+pieceName+" into "+targetName)

        }
        //text for action must include "score" or "collect" if action increases piecesScored
        //"collect (for stockpiling) increases piecesScored during stockpiling b/c the robot only picks up what it can score and would be too hard to track otherwise"
        function addPlotData(scenarioEncoded, action) {
            allPointsVsTime.push({ x: 150 - scenario.time, y: scenario.points });
            scenarioAction[scenarioEncoded] = (scenarioAction[scenarioEncoded] ?? "") + action + ";"
            scenarioTimes[scenarioEncoded] = (scenarioTimes[scenarioEncoded] ?? "") + scenario.time + ";";
            if (action.includes("score") || action.includes("collect")){
                allPieceCountVsTime.push({ x: 150 - scenario.time, y: piecesScored[0] });
            }
        }

        //create a scenario tree
        for (let i = 0; i < numberOfScenarios; ++i) {
            const scenarioDecoded = decodeScenario(i)
            for (let j in iteratingArrays) {
                scenario[iteratingArrays[j][0]] = iteratingArrays[j][Number(scenarioDecoded.charAt(j))+1]
            }

            //this can be optimized if put outside of scenario tree loop in calculate
            for(let i of iteratingArrays){
                if(i[0]==autonMovementName&&i[1]== "=Teleop"){
                    scenario[autonMovementName] = scenario["Teleop Movement (s)"]
                    break;
                }
            }

            //initialize the variables
            //last value set to 0 to keep track of what threshold the bot is up to
            piecesScored[0] = 0;
            holdingPiece[0] = 1;//start w/ holding one piece
            //holdingPiece[1]=1; //for a 2nd game piece
            scenario.time = 150; //seconds left in the game
            scenario.points = pointsForMobility;//will always get
            piecesScored[0] = 0;
            const trueBalancingTime = scenario["Balance/Climb/Hang (s)"] * (pointsForBalancing[0] > 0)

            //auton
            //if there's time to balance and score
            if (scenario.time - scenario[autonMovementName] / 2 - trueBalancingTime >= 135) {
                scenario.time -= scenario[autonMovementName] / 2
                //place pieces during auton
                while (scenario.time - scenario["Output (s)"] - trueBalancingTime >= 135 && piecesScored[0] < autonPieceLimit) {
                    autonScorePiece(i);
                    if (scenario.time - scenario[autonMovementName] / 2 - scenario["Intake (s)"] >= 135) {//autonMovement is cut in half b/c the bot only travels to pick up game pices, not also back 
                        scenario.time -= scenario[autonMovementName] / 2 + scenario["Intake (s)"];
                        holdingPiece[0] += scenario["Grab Amount (on average)"];
                        if (piecesScored[0] + holdingPiece[0] > autonPieceLimit) {
                            //need to reduce the time to grab since grabbing less than the grabAmount
                            holdingPiece[0] = autonPieceLimit - piecesScored[0]
                        }//prevents holding more pieces than allowed given the autonPieceLimit and the pieces already scored: this is needed in a game where you can pick up more than one piece at a time
                        if (scenario.time - scenario[autonMovementName] / 2 - scenario["Output (s)"] - trueBalancingTime >= 135) {
                            scenario.time -= scenario[autonMovementName] / 2;
                        } else if (pointsForBalancing[0] > 0) {//balance if auton-balance is allowed
                            scenario.time = 135 + trueBalancingTime;
                            scenario.points += pointsForBalancing[0];
                            scenario.time -= scenario["Balance/Climb/Hang (s)"];
                            addPlotData(i, "Balance/Climb/Hang");
                        } else { scenario.time = 135; }
                    }
                }
            } else if (scenario.time - trueBalancingTime >= 135) {//balance if auton-balance is allowed
                scenario.points += pointsForBalancing[0];
                scenario.time -= scenario["Balance/Climb/Hang (s)"];
                addPlotData(i, "Balance/Climb/Hang");
            }
            //teleop
            scenario.time = 135;
            //scenarioAction[i] = (scenarioAction[i] ?? "") + "start of teleop;";
            //scenarioTimes[i] = (scenarioTimes[i] ?? "") + "135;";
            
            // if holding pieces at beginning of teleop
            if (holdingPiece[0] > 0) {
                piecesScored[0] += holdingPiece[0];
                holdingPiece[0] = 0;
                scenario.time -= scenario["Output (s)"];
                scenario.points += pointsForBestScorer[1]

                allColorOverTime.push('rgb(0,0,0)')

                let linkscored = false
                if(doLinksExist){
                    let sum=0

                    for(let j of linkProgression){
                        sum+=j
                        if(piecesScored[0]-sum==0){
                            scenario.points+=linkPoints[1]
                            linkscored=true
                        }
                    }
                }
                if(linkscored) addPlotData(i, "scored speaker & link")
                
                else addPlotData(i, "scored coral into Lvl4")
            }//this doesn't count the time it takes to go from the charge station into the grid, which is bad for games when the place where mobility points are awarded is far away from a goal

            //scenario.time -= scenario["Teleop Movement (s)"];
            while (
                scenario.time - scenario["Teleop Movement (s)"] - scenario["Output (s)"] - scenario["Intake (s)"] - scenario["Balance/Climb/Hang (s)"]*( pointsForBalancing[1]>0 )
                - scenario['Algae dislodge (s)']*(piecesScored[0]==5||piecesScored[0]==7||piecesScored[0]==9)
                >=0
            ){ //if we want the program to see how much slower we can be w/out worsening score changing the 0 in ">=0" to some other number is a start.
                holdingPiece[0] += scenario["Grab Amount (on average)"];
                scorePiece(i);
                if(piecesScored[0]==42){//assuming 24 on level one, 12 on level four, and 6 on level two
                    break
                }
            }
            //endgame
            scenario.points += pointsForBalancing[1];
            scenario.time -= scenario["Balance/Climb/Hang (s)"];
            addPlotData(i, "Balance/Climb/Hang");
          //  scenario.time -= scenario["Output (s)"] + scenario["Intake (s)"];
          //  scenario.points += pointsForTrap[1];
            // since don't want to add to points scored, don't write "score"
        //    addPlotData(i , "scor_d trap" )

            //push chart-values that have scenarios as a dimension
            let rankpoint=   piecesScored[0] >= piecesScoredForRnkPnt[0]
            if(scenario["Alliance robots leave auton (Boolean)"]) ++rankpoint
            if(scenario["At least one alliance robot parks (Boolean)"]) ++rankpoint

            if ( rankpoint==3) {
                rnkValueVsScenario.push({ x: i, y: 3 });
                color.push("rgb(0,255,0)");
            }
            else if (rankpoint==2) {
                rnkValueVsScenario.push({ x: i, y: 2 });
                color.push("rgb(255,255,0)");
            }
            else if (rankpoint==1) {
                rnkValueVsScenario.push({ x: i, y: 1 });
                color.push("rgb(255,155,0)");
            } else {
                rnkValueVsScenario.push({ x: i, y: 0 });
                color.push("rgb(255,0,0)");
            }
            totalScoreVsScenario.push({ x: i, y: scenario.points });
            pieceCountVsScenario.push({ x: i, y: piecesScored[0] });
            pieceCountVsTotalScore.push({ x: scenario.points, y: piecesScored[0], scenario: i })
        }

   

        //Figure out which scenario each set of scatter points belongs to by defining the endpoints of each scenaraio i.e. where one scenario stops and a new one starts.
        //To define where the endpoints will appear, loop through each value in the allPointsVsTime, which holds coordinate points for everytime the bot scores points for each scenario.
        //When the points-value (aka y-property) of one coordinate pair is less than the points of another coordinate pair, there must be a new scenario.
        const endpoints = [-1];//its -1 b/c it's the ending-point in a scenario where nothing happens: it was done like this so the next scenario starts w/ zero (-1+1=0). I added one b/c the endpoint of one scenario is 1 plus the startpoint of another scenario.
        for (let i = 0; i < allPointsVsTime.length - 1; ++i) {
            if (allPointsVsTime[i].x > allPointsVsTime[i + 1].x) { endpoints.push(i); }
        }
        endpoints.push(allPointsVsTime.length - 1);
        //do the same for the pieces scored-time chart
        const endpointsofspecificPieceCountVsTime = [-1];
        for (let i = 0; i < allPieceCountVsTime.length - 1; ++i) {
            if (allPieceCountVsTime[i].x > allPieceCountVsTime[i + 1].x) { endpointsofspecificPieceCountVsTime.push(i); }
        }
        endpointsofspecificPieceCountVsTime.push(allPieceCountVsTime.length - 1);

        //create data arrays that will be used for the all inclusive chart's tooltip
        const groupsofpoints = [], coordinatesofgroups = [];
        for (let i in pieceCountVsTotalScore) {
            const coordinates = pieceCountVsTotalScore[i].x + ";" + pieceCountVsTotalScore[i].y;
            //If the coordinates already exists in coordinatesofgroups, then just need to add these coordinates to the list. Otherwise, need to create the said array before pushing it into the array.
            if (coordinatesofgroups.includes(coordinates)) { groupsofpoints[coordinatesofgroups.indexOf(coordinates)].push(decodeScenario(i)); }
            else {
                groupsofpoints.push([decodeScenario(i)]);
                coordinatesofgroups.push(coordinates);
            }
        }
        const zeroindices = [], maxs = [], mins = [];
        for (let i of groupsofpoints) {
            zeroindices.push(i[0]);
            const min = [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity];
            const max = [-Infinity, -Infinity, -Infinity, -Infinity, -Infinity, -Infinity, -Infinity];

            for (let j of i) {
                for (let scenarioattribute = 0; scenarioattribute < 6; ++scenarioattribute) {
                    if (j[scenarioattribute] < min[scenarioattribute]) {
                        min[scenarioattribute] = j[scenarioattribute];
                    }
                    if (j[scenarioattribute] > max[scenarioattribute]) {
                        max[scenarioattribute] = j[scenarioattribute];
                    }
                }
            }
            maxs.push(max);
            mins.push(min);
        }

        //load charts
        updatedata(0);
        
        window.addEventListener("load", function (e) { //only initialize chart once window loads completely to avoid context issues            
            const scenariochart = new Chart("scenarioChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: pieceCountVsTotalScore,
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'Pieces Scored/collected if stockpile - Total Score'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                //if this is the first point in a group, than activate all the details for that group
                                const scenario = decodeScenario(tooltipItem.index);
                                if (zeroindices.includes(scenario)) {
                                    document.getElementById("tooltip").innerHTML = "";

                                    let scenarios = groupsofpoints[zeroindices.indexOf(scenario)]
                                    const lessEfficientIndices = []
                                    for(let i = 0; i<scenarios.length-1;++i){
                                        for(let j = i+1; j<scenarios.length-1;++j){
                                            if(j==i)continue

                                            let iIsLessEfficientThanJ=false;
                                            let iIsMoreEfficientThanJ=false;
                                            for(let k in iteratingArrays){
                                                if(scenarios[i][k]>scenarios[j][k]) iIsMoreEfficientThanJ=true
                                                if(scenarios[i][k]<scenarios[j][k]) iIsLessEfficientThanJ=true
                                            }
                                            if(iIsLessEfficientThanJ&&!iIsMoreEfficientThanJ) lessEfficientIndices.push(i)
                                            else if(!iIsLessEfficientThanJ&&iIsMoreEfficientThanJ) lessEfficientIndices.push(j)
                                        }
                                    } 
                                    for(let i = 0; i<scenarios.length-1;++i){
                                        if(lessEfficientIndices.includes(i)) continue
                                        const detail = document.createElement("details");
                                        document.getElementById("tooltip").appendChild(detail);
                                        let details = "<summary>" + scenarios[i].substring(0,iteratingArrays.length-iteratingArraysVisibleInputOffset) + "</summary>"
                                        for(let j =0; j<iteratingArrays.length;++j){
                                            if(j>=iteratingArrays.length-iteratingArraysVisibleInputOffset){
                                                //details += iteratingArrays[j][0] + ": " + iteratingArrays[j][Number(scenarios[i].charAt(j)) + 1] + "<br>"
                                                break
                                            }
                                            else {
                                                details += iteratingArrays[j][0] + ": " + iteratingArrays[j][Number(scenarios[i].charAt(j)) + 1] + "<br>"
                                            }
                                                
                                        }
                                        detail.innerHTML = details
                                    }
                                }
                            },
                            //When points overlap, can only have one footer, but multiple labels.
                            footer: function (tooltipItems, data) {
                                return [
                                    "Total Score: " + pieceCountVsTotalScore[tooltipItems[0].index].x,
                                    "Pieces Scored: " + pieceCountVsTotalScore[tooltipItems[0].index].y,
                                    "Scenarios that exist: " + groupsofpoints[zeroindices.indexOf(decodeScenario(tooltipItems[0].index))].length
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        if (event.shiftKey) {
                            /*const element = scenariochart.getElementAtEvent(evt);
                            if (element.length > 0) {
                                const ind = element[0]._index;
                                if(!zeroIndicesPointsClicked.includes(ind)){//if not already included
                                    zeroIndicesPointsClicked.push(ind);
                                    //somehow maybe highlight it?
                                    
                                    pointsClicked.push([]);
                                    for(let i of groupsofpoints[ind]){
                                       pointsClicked[pointsClicked.length-1].push(i);
                                    }
                                    document.getElementById("shiftkey").innerHTML=pointsClicked;
                                }
                                else{
                                    pointsClicked.splice(zeroIndicesPointsClicked.indexOf(ind));
                                    zeroIndicesPointsClicked.splice(zeroIndicesPointsClicked.indexOf(ind));
                                    document.getElementById("shiftkey").innerHTML=pointsClicked;
                                }
                            }*/
                        }
                        else {
                            zeroIndicesPointsClicked.splice(0, this.length);
                            pointsClicked.splice(0, this.length);
                            document.getElementById("shiftkey").innerHTML = "";
                            const element = scenariochart.getElementAtEvent(evt);
                            if (element.length > 0) {
                                const ind = element[0]._index;
                                if (confirm('Do you want to see this scenario?')) {
                                    console.log(ind)
                                    updatedata(ind);
                                    
                                    var ctx = document.getElementById('psotchart').getContext('2d');
                                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                                    psotchart.update();
                                    scoretimechart.update();
                                }
                            }
                        }

                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: {
                                min: pieceCountVsTotalScore[pieceCountVsTotalScore.length - 1].x,
                                max: pieceCountVsTotalScore[0].x,
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored/Collected if stockpile",
                            },
                            ticks: {
                                min: pieceCountVsTotalScore[pieceCountVsTotalScore.length - 1].y,
                                max: pieceCountVsTotalScore[0].y,
                            }
                        }],
                    }
                }
            });
            const rnkpntchart = new Chart("rnkpntChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: rnkValueVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'RANK POINTS - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                if (rnkValueVsScenario[tooltipItem.index].y === 0) { return "0"; }//there was a bug where if it was 0, then nothing it wouldn't show this
                                return rnkValueVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.slice(0,iteratingArrays.length-iteratingArraysVisibleInputOffset)
                                    .map(
                                        ([key, ...values], indexOfMap) =>
                                            key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]
                                    )
                                ;
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = rnkpntchart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                try {
                                    psotchart.update();
                                    scoretimechart.update();
                                } catch (error) {
                                    console.log(error);
                                }

                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Rank Points",
                            },
                            ticks: { min: 0, max: 3, stepSize: 1 }
                        }],
                    }
                }
            });
            const pschart = new Chart("psChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: totalScoreVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'TOTAL SCORE - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return totalScoreVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.slice(0,iteratingArrays.length-iteratingArraysVisibleInputOffset)
                                    .map(
                                        ([key, ...values], indexOfMap) =>
                                            key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]
                                    )
                                ;
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = pschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: { min: totalScoreVsScenario[totalScoreVsScenario.length - 1].y, max: totalScoreVsScenario[0].y }
                        }],
                    }
                }
            });
            const piecesschart = new Chart("piecesScoredchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: pieceCountVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return pieceCountVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.slice(0,iteratingArrays.length-iteratingArraysVisibleInputOffset)
                                    .map(
                                        ([key, ...values], indexOfMap) =>
                                            key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]
                                    )
                                ;
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = piecesschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: pieceCountVsScenario[pieceCountVsScenario.length - 1].y, max: pieceCountVsScenario[0].y }
                        }],
                    }
                }
            });

            const psotchart = new Chart("psotchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        borderColor: specificColorOverTime.map(
                            color=> {return color=="rgb(255,255,255)"? "rgb(0,0,0)":color}
                        ),
                        pointBackgroundColor: specificColorOverTime, //"rgb(0,0,255)",
                        data: specificPieceCountVsTime
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED/collected if stockpile - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored/collected if stockpile",
                            },
                            ticks: { min: 0, max: pieceCountVsScenario[0].y },
                        }],
                    }
                }
            });
            const scoretimechart = new Chart("myChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: specificPointsVsTime
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'SCORE - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Score",
                            },
                            ticks: { min: 0, max: totalScoreVsScenario[0].y }
                        }],
                    }
                }
            });
        });
    </script>
</body>

</html>
